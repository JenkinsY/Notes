## 栈和堆的区别

栈：**申请栈空间时不需要指明大小**。**栈是向低地址扩展的数据结构，是一块连续的内存的区域，因此一般不会有内存碎片问题**。

堆：**申请堆空间时需要指明大小**。**堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，因此也会产生内存碎片问题**。

栈：存放局部变量、函数参数

堆：堆中的具体内容可以通过程序员安排。

## 同步和异步

#### 举例电脑上的同步和异步

## 线程和进程

#### 线程通信和进程通信

##### 进程间的通信方式：管道、信号量、消息队列、信号 (sinal ) 、共享内存、套接字(socket )

**线程间的通信方式**

- 锁机制：包括互斥锁、条件变量、读写锁
     *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
     *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
     *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

- 信号机制(Signal)：类似进程间的信号处理

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

#### 进程空间和线程空间

#### 内核线程和用户线程

## C++三大特性

#### friend和封装是否冲突

#### 如何延长对象的生命周期

#### const修饰函数什么情况下可以修改成员数据

#### 模板有几种

#### static关键字

#### 多继承好处坏处

#### 虚基类

## 常用设计模式有几种

#### 单例模式

频繁实例化然后又销毁的对象,使用单例模式可以提高性能

一个私有构造函数(确保只能单例类自己创建实例)

一个私有静态变量(确保只有一个实例)

一个公有静态函数(给使用者提供调用方法)

- 懒汉（线程不安全）：先不创建实例,当第一次被调用时,在创建实例。如果多个线程同时进入了创建，就会实例化多个实例，解决：添加互斥量
- 饿汉（线程安全）：提前实例化好了一个实例,避免了线程不安全问题的出现，但如果不使用会造成资源浪费

#### 观察者模式

它定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时,会通知所有的观察者对象,使他们能够自动更新自己。

## 回调函数

回调函数的使用可以大大提升编程的效率

最著名的回调函数调用有C/C++标准库stdlib.h/cstdlib中的快速排序函数qsort和二分查找函数bsearch中都会要求的一个与strcmp类似的参数，用于设置数据的比较方法。

回调函数就相当于一个[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)处理函数，由系统在符合你设定的条件是自动调用

也就是说，把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。

函数 F1 调用函数 F2 的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数 F2 执行的过程中，函数F2 调用了函数 F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数 F3 就是回调函数。

